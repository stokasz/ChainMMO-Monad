// SPDX-License-Identifier: MIT
pragma solidity ^0.8.26;

import {ChainMMOBase} from "../helpers/ChainMMOBase.t.sol";
import {GameConstants} from "../../src/libraries/GameConstants.sol";
import {GameTypes} from "../../src/libraries/GameTypes.sol";

contract MicroEconomicsExploitHardeningTest is ChainMMOBase {
    function test_SplitPremiumPurchaseCannotUnderpriceAfterCurveKickIn() public {
        uint256 characterId = _createCharacter(playerA, "CurveParity");

        vm.startPrank(playerA);
        token.approve(address(feeVault), type(uint256).max);

        uint256 remaining = GameConstants.FIRST_DAILY_LOOTBOXES;
        while (remaining > 0) {
            uint16 amount = remaining > GameConstants.MAX_BUY_PER_TX ? GameConstants.MAX_BUY_PER_TX : uint16(remaining);
            (uint256 cost,) = feeVault.quotePremiumPurchase(characterId, GameTypes.Difficulty.EASY, amount);
            feeVault.buyPremiumLootboxes{value: cost}(characterId, GameTypes.Difficulty.EASY, amount);
            remaining -= amount;
        }

        (uint256 batchCost,) = feeVault.quotePremiumPurchase(characterId, GameTypes.Difficulty.EASY, 2);

        (uint256 firstSingle,) = feeVault.quotePremiumPurchase(characterId, GameTypes.Difficulty.EASY, 1);
        feeVault.buyPremiumLootboxes{value: firstSingle}(characterId, GameTypes.Difficulty.EASY, 1);

        (uint256 secondSingle,) = feeVault.quotePremiumPurchase(characterId, GameTypes.Difficulty.EASY, 1);
        vm.stopPrank();

        assertEq(batchCost, firstSingle + secondSingle);
    }

    function test_QuoteMmoCostCapsAtMaxLevelAndMaxTxAmount() public {
        uint256 characterId = _createCharacter(playerA, "MmoCap");
        _forceLevel(characterId, type(uint32).max);

        (, uint256 mmoCost) =
            feeVault.quotePremiumPurchase(characterId, GameTypes.Difficulty.CHALLENGER, GameConstants.MAX_BUY_PER_TX);

        assertEq(mmoCost, GameConstants.MMO_SINK_MAX_PER_LOOTBOX * GameConstants.MAX_BUY_PER_TX);
    }

    function test_FeeCurvesRemainMonotonicAndCappedAtExtremeLevels() public view {
        uint32[7] memory levels = [uint32(21), 22, 30, 60, 120, 2_000, type(uint32).max];

        uint256 prevEntry;
        uint256 prevRepair;
        for (uint256 i = 0; i < levels.length; i++) {
            uint32 level = levels[i];
            uint256 entryFee = world.runEntryFee(level);
            uint256 repairFee = world.repairFee(level);

            assertLe(entryFee, GameConstants.RUN_ENTRY_MAX);
            assertLe(repairFee, GameConstants.REPAIR_MAX);

            if (i > 0) {
                assertGe(entryFee, prevEntry);
                assertGe(repairFee, prevRepair);
            }

            prevEntry = entryFee;
            prevRepair = repairFee;
        }
    }

    function test_PremiumMmoSinkCurveIsMonotonicAcrossProgressionBands() public {
        uint256 characterId = _createCharacter(playerA, "SinkCurve");
        uint32[6] memory levels = [uint32(10), 11, 20, 30, 40, 50];

        uint256 prevCost;
        for (uint256 i = 0; i < levels.length; i++) {
            _forceLevel(characterId, levels[i]);
            (, uint256 mmoCost) = feeVault.quotePremiumPurchase(characterId, GameTypes.Difficulty.EASY, 1);
            if (i > 0) {
                assertGe(mmoCost, prevCost);
            }
            prevCost = mmoCost;
        }
        assertGt(prevCost, 0);
    }

    function test_VarianceBoundCreditsCannotBeCrossDrainedByDifferentMode() public {
        uint256 characterId = _createCharacter(playerA, "VarianceIsolation");

        vm.startPrank(playerA);
        _equipTierTwoKit(characterId, playerA, 140_000);
        _winStableTierThreeCredit(characterId);
        _buyOnePremiumEasy(characterId);

        assertEq(world.lootboxCredits(characterId, 3), 2);
        assertEq(world.lootboxBoundCredits(characterId, 3, GameTypes.VarianceMode.STABLE), 1);

        bytes32 secret = keccak256("swingy-open");
        uint64 nonce = 141_001;
        bytes32 hash =
            world.hashLootboxOpen(secret, playerA, characterId, nonce, 3, 2, GameTypes.VarianceMode.SWINGY, true);

        uint256 commitId = world.commitActionWithVariance{value: world.commitFee()}(
            characterId, GameTypes.ActionType.LOOTBOX_OPEN, hash, nonce, GameTypes.VarianceMode.SWINGY
        );

        _rollToReveal(commitId);
        uint16 opened = world.revealOpenLootboxesMax(commitId, secret, 3, 2, GameTypes.VarianceMode.SWINGY);
        vm.stopPrank();

        assertEq(opened, 1);
        assertEq(world.lootboxCredits(characterId, 3), 1);
        assertEq(world.lootboxBoundCredits(characterId, 3, GameTypes.VarianceMode.STABLE), 1);
    }

    function _buyOnePremiumEasy(uint256 characterId) internal {
        (uint256 cost,) = feeVault.quotePremiumPurchase(characterId, GameTypes.Difficulty.EASY, 1);
        feeVault.buyPremiumLootboxes{value: cost}(characterId, GameTypes.Difficulty.EASY, 1);
    }

    function _winStableTierThreeCredit(uint256 characterId) internal {
        for (uint256 i = 0; i < 24; i++) {
            bytes32 secret = keccak256(abi.encode("stable-credit", i));
            uint64 nonce = uint64(140_100 + i);
            bytes32 hash = world.hashDungeonRun(
                secret, playerA, characterId, nonce, GameTypes.Difficulty.EASY, 2, GameTypes.VarianceMode.STABLE
            );

            uint256 commitId = world.commitActionWithVariance{value: world.commitFee()}(
                characterId, GameTypes.ActionType.DUNGEON_RUN, hash, nonce, GameTypes.VarianceMode.STABLE
            );

            _rollToReveal(commitId);
            world.revealStartDungeon(commitId, secret, GameTypes.Difficulty.EASY, 2, GameTypes.VarianceMode.STABLE);
            _drainRun(characterId);

            if (world.lootboxBoundCredits(characterId, 3, GameTypes.VarianceMode.STABLE) > 0) {
                return;
            }
        }
        revert("stable credit unavailable in bounded attempts");
    }

    function _equipTierTwoKit(uint256 characterId, address who, uint64 seedBase) internal {
        for (uint8 slot = 0; slot < 8; slot++) {
            uint256 itemId = _forceMintItem(who, GameTypes.Slot(slot), 2, seedBase + slot);
            world.equipItem(characterId, itemId);
        }
    }

    function _drainRun(uint256 characterId) internal {
        while (true) {
            (
                bool active,
                uint8 roomCount,
                uint8 roomsCleared,
                uint32 hp,
                uint32 mana,
                uint8 hpPotionCharges,
                uint8 manaPotionCharges,
                uint8 powerPotionCharges,
                uint32 dungeonLevel,
                GameTypes.Difficulty difficulty
            ) = world.getRunState(characterId);

            roomCount;
            roomsCleared;
            hp;
            mana;
            hpPotionCharges;
            manaPotionCharges;
            powerPotionCharges;
            dungeonLevel;
            difficulty;

            if (!active) return;
            world.resolveNextRoom(characterId, GameTypes.PotionChoice.NONE, GameTypes.AbilityChoice.NONE);
        }
    }
}
